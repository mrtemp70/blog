**1.**       **Single responsibility principle**: (একটি ক্লাসের কাজ বা উদ্দেশ্য শুধু একটা হবে। যদি সেন্ড মেইলের জন্য ক্লাস বানাই তবে সেই ক্লাসে কোনোমতেই পেমেন্ট ফিচারের কোড রাখা যাবে না) One class should do one thing and do it well. The condition of SRP is that a Class will have only one function/purpose, That is, there will be different classes for each different task. [(See 5 principle in bangla)](https://medium.com/%E0%A6%AA%E0%A7%8D%E0%A6%B0%E0%A7%8B%E0%A6%97%E0%A7%8D%E0%A6%B0%E0%A6%BE%E0%A6%AE%E0%A6%BF%E0%A6%82-%E0%A6%AA%E0%A6%BE%E0%A6%A4%E0%A6%BE/solid-principle-part-1-b5ff613de6a3#:~:text=SOLID%20%E0%A6%B9%E0%A6%9A%E0%A7%8D%E0%A6%9B%E0%A7%87%20Object%20Oriented%20Programming%20%E0%A6%8F%E0%A6%B0%20%E0%A6%97%E0%A7%81%E0%A6%B0%E0%A7%81%E0%A6%A4%E0%A7%8D%E0%A6%AC%E0%A6%AA%E0%A7%82%E0%A6%B0%E0%A7%8D%E0%A6%A3%20%E0%A7%AB%E0%A6%9F%E0%A6%). The idea behind the SRP is to reduce the complexity of code by ensuring that each class or module has a clear and distinct responsibility. This makes it easier to test, debug, and modify the code since the responsibilities are well-defined and isolated. When a class or module has multiple responsibilities, it can become difficult to understand and change, as well as making it more likely for bugs to appear.

**2.**       **Open Closed design principle:** (যদি একটা প্রজেক্ট ৫ বছর পরে ইডিট করা প্রয়োজন হয়। তখন একটা ক্লাসে মডিফিকেশন না করে সেই ক্লাস এক্সটেন্ড করে নিতে হবে। কারন ক্লাস মডিফাই করলে দেখা যাবে সেই ক্লাস কতজায়গায় ইউজ হইছে তার ঠিক নাই, যদি মডিফাই করি তবে বাগ দেখা দিবে। ধরি, জিওম্যাট্রি এবং এডভান্স জিওম্যাট্রি)। Open for extension, closed for modification. OCP says that the entities (class, function, module) of our software should be designed in such a way that even if new requirements come in the future, its behavior can be changed by extending the existing code instead of modifying the existing code. It should be noted here that behavior refers to behavioral changes in the source code. Straight away, our software entities will be open for extension but closed for modification. Robert C. Martin refers to this principle as the foundation of maintainable and reusable code. Overall, the Open Closed principle is an important concept in software design that encourages developers to write code that is adaptable, scalable, and easy to maintain over time.

_**3.**_       **Liskov substitutin principle:**  (এটি মূলত বলে ইনহেরিট্যান্স করা যাবে নাকি যাবেনা (ইনহেরিটেন্স এপ্লাই করার পর মেক সেন্স করে কিনা দেখতে হবে)। যদি প্যারেন্ট ক্লাস আর চাইল্ড ক্লাস একই টাইপের না হয় তবে ইনহেরিট্যান্স করা যাবেনা। যেমন প্রেন আর ফল একে অপরকে ইনহেরিট করতে পারবে না। যদি 2D Board (Parent class), 3D Board(child class) কে ভ্যালিড ইনহেরিট করতে পারবে না এবং পেরেন্ট ক্লাসের সব কিছু চাইল্ড ইউজ করতে পারবে না ) _The Liskov Substitution Principle (LSP) is a fundamental principle in object-oriented programming (OOP)_ _that states that objects of a superclass should be able to be replaced with objects of a subclass without affecting the correctness of the program__. In other words,_ _any instance of a class should be able to be replaced by an instance of any of its subclasses without causing any errors or unexpected behavior._ _The LSP is important because it ensures that the design of the class hierarchy is correct and that the behavior of the program is consistent. Violations of the LSP can lead to errors, unexpected behavior, and difficulties in maintenance and debugging._

**4.**       **Interface segregation principle:** (এই প্রিন্সিপালের কাজ হলো যতোটা পারা যায় ছোট ছোট স্পেসিফিক ইন্টারফেস বানাবো। ধরি একটি বার্ড ক্লাস বানালাম যার ইন্টারফেস IBird. এখন কিছু বার্ড আছে উড়তে পারে কিছু আছে উড়তে পারে না, কিছু আছে সাতার কাটতে পারে কিছু পারে না। তো এখন যদি যারা উড়তে পারে তাদের জন্য আলাদা ইন্টারফেস বানাই, যারা উড়তে পারে না তাদের জন্য আলাদা তাহলে এটা রিউজেবল হয়ে যাবে)  Avoid monolithic (একশিলা) interface, reduce pain on client side**.** We should divide interface as small as possible. As a result we can reuse and use it highest class. The Interface Segregation Principle (ISP) is a fundamental principle in software engineering that states that clients should not be forced to depend on methods that they do not use. In other words, a software interface should be designed in such a way that it provides only the methods that are relevant and necessary for the clients that use it. This helps to prevent unnecessary dependencies and reduces the impact of changes to the interface. The ISP is important because it promotes the creation of interfaces that are easy to use, easy to understand, and easy to maintain. By breaking down large, complex interfaces into smaller, more focused interfaces, developers can create more modular and reusable code. The ISP is closely related to other software design principles, such as the Single Responsibility Principle and the Dependency Inversion Principle. Together, these principles help to create software that is modular, maintainable, and extensible over time. Overall, the Interface Segregation Principle is an important concept in software engineering that helps to create software that is more reliable, more maintainable, and easier to use.

**5.**        
**Dependancy Inversion Principle:** (লোয়ার লেভেল ক্লাস ঘন ঘন মডিফাই হয়। এতে করে হায়ার লেভেল ক্লাস ভেঙ্গে যেতে পারে যদি লোয়ার লেভেলের দিকে রেফারেন্স করা থাকে। তাই সরাসরি একে অপরের মধ্যে রেফারেন্সিং না করে মাঝে একটি ইন্টারফেস দিয়ে দুটির রেফারেন্সই ইন্টারফেসকে রেফার করে দিলে সবাই ইন্টারফেসের উপর ডিপেন্ডেন্ট হয়ে যায়।) Don’t ask, let framework give to you. The Dependency Inversion Principle (DIP) is a fundamental principle in object-oriented programming that states that high-level modules should not depend on low-level modules, but instead depend on abstractions. In other words, instead of having high-level modules that depend on the implementation details of low-level modules, the dependencies should be inverted, so that both high-level and low-level modules depend on abstractions. This principle is important because it promotes the creation of flexible and reusable code that is easy to modify and extend. By depending on abstractions rather than concrete implementations, the software becomes less tightly coupled, making it easier to modify or replace components without affecting the rest of the system. The DIP is often used in conjunction with other design patterns and principles, such as the Factory Method pattern and the Interface Segregation Principle, to create software that is modular, flexible, and easy to maintain. Overall, the Dependency Inversion Principle is an important concept in software engineering that helps to create software that is more extensible, more maintainable, and less tightly coupled.

![[principle.png]]

**6.**       **Don't Repeat Yourself (DRY) principle:** (কোড ডুপ্লিকেশন করা যাবে না) Avoids duplication in code. The "Don't Repeat Yourself" (DRY) principle is a software development principle that encourages programmers to avoid duplicating code or logic in multiple places within a software system. The idea is to write code that is reusable, modular, and maintainable. The DRY principle aims to reduce the risk of errors or bugs in the code and improve the overall quality of the software. It also helps to improve the efficiency of the development process by reducing the amount of code that needs to be written, tested, and maintained. In practical terms, following the DRY principle means that when a piece of code is needed in multiple places, it should be abstracted into a reusable function or class. This way, any changes or updates to the code only need to be made in one place, making it easier to maintain and reducing the likelihood of introducing errors. Overall, the DRY principle is an important concept in software development that can help improve the quality, efficiency, and maintainability of code.

**7.**       **Encapsulate What Changes principle:** (ধরি আমাদের কোডে কোথাও হার্ডকোড করে যদি Key বসিয়ে দেই যার ফলে ফিউচার কোড চেঞ্জ করি বা Key চেঞ্জ করি তবে কোড ক্রাস করবে, তাই এটাকে আমরা এপ সেটিং এ রাখতে পারি বা হাইড করে রাখতে পারি। আবার,  যদি আমাদের প্রজেক্ট entity framework, বা অন্য কোনো মেথড use করে করা থাকে আর future এ entity framework এর বদলে অন্য কোনো orm এসে পড়ে তবে কিন্তু প্রজেক্ট মডিফাই করতে গিয়ে crush করবে তাই যদি encapsulate করা থাকে তাহলে আর প্রবলেম হবে না আর আমরা সহজেই অন্য কোথাও মুভ করতে পারবো। যদিও entity framework এর code encapsulate (user access control) করা ) Hides implementation detail, helps in maintenance. The "Encapsulate What Changes principle" principle is a software design principle that aims to reduce the impact of changes made to one part of a software system on other parts of the system. The principle suggests that any part of the system that is likely to change frequently or independently of other parts should be encapsulated or hidden from the rest of the system. Encapsulation involves grouping together related data and functionality into a single unit or module, and restricting access to that module from other parts of the system. This helps to minimize the ripple effects of any changes made to that module, as the changes will be contained within the module and will not affect other parts of the system. By following the Encapsulate What Changes principle, software developers can create more flexible and maintainable systems that are easier to modify and extend over time. It is often used in conjunction with other design principles, such as the Single Responsibility Principle and the Open-Closed Principle, to create modular, loosely coupled systems.

  ![[principle2.png]]

**8.**       **Favor Composition over Inheritance principle:** (যতটা পারা যায় ইনহেরিটেন্স avoid করা উচিৎ। খুব বেশি  হলে ১ লেভেল পর্যন্ত inheritance করে then composition করবো (Car car এইরকম অব্জেক্ট ডিক্লেয়ার করে ইউজ করেও ইনহেরিটেন্স এভোয়েড করা যায়)। আমরা মূলত ইনহেরিটেন্স সাবটাইপ তৈরি করার জন্য ইউজ করি সাথে সাথে by product হিসেবে কোড রিইউজ করা যায়। শুধুমাত্র কোড রিইউজের জন্য আমরা কখনো ইনহেরিটেন্স এপ্পলাই করবো না. উল্লেখ্য যে বাড়িতে জানালা থাকবেই এটা strong bonding, হাসপাতাল একমাত্র ডাক্তার থাকতে আর অন্য কোথাও না, এখানে হাসপাতাল আর ডাক্তারের bonding is week bonding, ,হস্পিটাল ছাড়াও ডাক্তার থাকতে পারে এমন বন্ডিং aggregation bonding generally বলা হয় association,  এখানে composition দিয়ে বুঝানো হয়েছে স্ট্রং বন্ডিং এর কথা ) Code reuse without cost of inflexibility(inheritance). The "favor composition over inheritance" principle is a design principle in object-oriented programming. It suggests that instead of creating a new class by inheriting from an existing class, it is better to create a new class by composing (or combining) objects from existing classes. In other words, instead of inheriting all the methods and properties of a parent class, a new class should be created by combining the functionality of existing classes through composition. This can be achieved by creating new objects of those classes as instance variables within the new class and using them to implement the desired functionality. The benefit of this approach is that it allows for greater flexibility and modularity in the design of the code. It also helps to reduce the complexity of the code and avoid potential issues that can arise from deep inheritance hierarchies. However, there may still be situations where inheritance is more appropriate, such as when there is a strong "is-a" relationship between the parent and child classes.

**9.**       **Programming for interface principle:** (Interface use করে code লিখার practice করা) Helps in maintenance, improves flexibility

**10.**    **Delegation (****প্রতিনিধি****) principle:** (কাজকে যতখানি পারা যায় অন্যকে দিয়ে দাও। যেমন একজন CEO এর পিয়ন খুজা বেমানান) Don’t do all things by yourself, delegate it. The Delegation Principle is a management concept that involves assigning tasks and responsibilities to individuals or teams based on their skills, expertise, and competence. It is based on the idea that a manager or leader should delegate tasks to the lowest possible level of the organization where the person or team has the necessary knowledge and skills to complete the task effectively. The Delegation Principle is important because it allows managers to focus on higher-level tasks and responsibilities, while empowering their subordinates to take on more responsibility and develop their skills. By delegating tasks, managers can also increase the productivity of the organization as a whole and create a more efficient and effective work environment. However, effective delegation requires clear communication, trust, and accountability. Managers must communicate expectations clearly and provide the necessary resources and support for their subordinates to successfully complete the task. They must also trust their subordinates to make decisions and take ownership of the task, while still holding them accountable for the results.