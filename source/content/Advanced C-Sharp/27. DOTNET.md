If we need to work with random version like ASP.NET Core 3.1 then must check below two from visual studio installer (If not exist then download from internet)

·         **SDK**: Helps you build software.

·         **Runtime**: Allows you to run software.

In **program.cs**, (More [https://www.c-sharpcorner.com/article/project-structure-in-asp-net-core-3-1-web-application/](https://www.c-sharpcorner.com/article/project-structure-in-asp-net-core-3-1-web-application/) and [https://www.c-sharpcorner.com/article/what-is-startup-class-and-program-cs-in-asp-net-core/)](https://www.c-sharpcorner.com/article/what-is-startup-class-and-program-cs-in-asp-net-core/))

``` csharp


public class Program
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run(); // we call method name CreateHostBuilder (which is exist below)
    }
    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseStartup<Startup>(); // we can use custom class intead of Startup class here
            });
}
```

In **Startup**,

**ConfigureServices Method**:  
  
This is an optional method in Startup class which is used to configure services for application. When any request comes to the application, he ConfigureService method will be called first.  
  
ConfigureServices method includes IServiceCollection parameter to register services. This method must be declared with a public access modifier, so that environment will be able to read the content from metadata.

``` csharp
public void ConfigureServices(IServiceCollection services)  
{  
   services.AddMvc();  
} 
```

**Configure Method**:

The Configure method is used to specify how the application will respond in each HTTP request. This method is mostly used for registering middleware in HTTP pipeline. This method method accept IApplicationBuilder parameter along with some other services like IHostingEnvironment and ILoggerFactory. Once we add some service in ConfigureService method, it will be available to Configure method to be used.

``` csharp
public void Configure(IApplicationBuilder app)  
{  
    app.UseMvc();  
} 
```

· **What is middlewire? (**[https://www.c-sharpcorner.com/article/overview-of-middleware-in-asp-net-core/](https://www.c-sharpcorner.com/article/overview-of-middleware-in-asp-net-core/))

Each component (middleware) in the pipeline can inspect, modify, or pass on an HTTP request or response.
![[dotnet-middleware.png]]The first configured middleware has received the request, modified it (if required), and passed control to the next middleware. Similarly, the first middleware is executed at the last while processing a response if the echo comes back down the tube.

![[dotnet-chain.png]]

· **Create Custom Middleware**

[https://youtu.be/tx1hsf_R-0o?si=RTi9bVrQg3KeGGV8](https://youtu.be/tx1hsf_R-0o?si=RTi9bVrQg3KeGGV8)

Custom middleware is often necessary to address specific requirements or functionalities that are not adequately handled by built-in or existing middleware components.

In summary, custom middleware is needed to address unique requirements, integrate with external systems, optimize performance, enforce security measures, meet compliance requirements, bridge gaps between modern and legacy systems, and implement application-specific features. It provides developers with the flexibility to extend and customize the middleware pipeline to suit the needs of their applications.


  •	Dependency injection? Why need register service or resolve service in startup? When need?
	Answer: N/A
•	Attributes and data annotations
	Answer: N/A
•	Autofac configuration in asp.net 3.1
	Answer: See This See this blog [link](https://www.c-sharpcorner.com/article/serilog-in-asp-net-core-3-1/)
•	Serilog configuration in asp.net 3.1
	Answer: Install Serilog.AspNetCore and then See this blog [link](https://www.c-sharpcorner.com/article/serilog-in-asp-net-core-3-1/)

|   |
|---|
|Loose coupling is a design principle in software engineering where components or modules are designed to interact with each other with minimal dependencies. In a loosely coupled system, changes to one component do not require changes to other components, allowing for easier maintenance, scalability, and flexibility.<br><br>Key characteristics of loose coupling include:<br><br>Minimal Dependencies: Components interact with each other through well-defined interfaces or contracts, rather than directly accessing each other's internal details.<br><br>High Cohesion: Each component focuses on a specific task or responsibility, reducing the likelihood of unintended side effects when changes are made.<br><br>Flexibility: Components can be replaced or modified without affecting other parts of the system, promoting reusability and easier adaptation to changing requirements.<br><br>Ease of Testing: Components can be tested independently, facilitating unit testing and overall system testing.<br><br>Overall, loose coupling fosters modular and maintainable software architectures, enabling easier development and evolution of complex systems.|

· **MediatR library vs Mediator pattern?**

Answer: MediatR is an implementation of the mediator pattern specifically tailored for .NET applications. While the concepts are related, MediatR provides a concrete implementation with additional features and conveniences, such as request/response handling and pipeline behaviors.

**Mediator Pattern:**

· The mediator pattern is a design pattern that promotes loose coupling between objects by encapsulating how objects interact with each other. Instead of objects directly communicating with each other, they communicate through a mediator object.

· In the mediator pattern, the mediator object coordinates communication between multiple objects, reducing dependencies between them.

· This pattern is commonly used in event-driven architectures, GUI systems, and other scenarios where decoupling is desirable.

**MediatR:**

· MediatR is a library for .NET that implements the mediator pattern. It provides a simple and straightforward way to implement the mediator pattern in your applications.

· With MediatR, you define requests (commands or queries) and handlers for those requests. The mediator acts as a central hub for sending requests to their corresponding handlers.

· MediatR simplifies the implementation of the mediator pattern in .NET applications, making it easier to achieve decoupling and separation of concerns.

· **Implementing CQRS Pattern:**

MediatR seamlessly enables the implementation of Command Query Responsibility Segregation (CQRS) pattern in [ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0) or .NET 6 applications. CQRS separates read operations, update operation, delete operation (queries) from write operations (commands), providing a clear distinction between data retrieval and modification. With MediatR, developers can easily create a public class to record and order the content for CQRS implementation in their applications.

With MediatR's support for CQRS, you can easily handle commands, queries, and notifications in a centralized manner using the public class. This approach fosters better scalability as you can optimize read-heavy or write-heavy scenarios independently. By segregating concerns based on intent, you can design more efficient systems that align with specific business requirements for the application request. Additionally, the FakeDataStore can be utilized to simulate data storage for testing purposes.

![[dotnet-mediatR.png]]

Here is implementation video and documentation: [https://www.youtube.com/watch?v=ykC3Ty-3U7g&ab_channel=CodeMaze](https://www.youtube.com/watch?v=ykC3Ty-3U7g&ab_channel=CodeMaze) and [https://code-maze.com/cqrs-mediatr-in-aspnet-core/](https://code-maze.com/cqrs-mediatr-in-aspnet-core/)

![[dotnet-mediatR2.png]]